---
description: 
globs: *.rs
alwaysApply: false
---
---
description: This master rule provides comprehensive best practices for Rust development. It guides the AI to write idiomatic, efficient, secure, and maintainable Rust code by leveraging a full suite of specialized tools via the MCP server for context-aware assistance.
globs: ["*.rs"]
---

# Rust Best Practices & Tool Integration

## 1. Core Philosophy

Your primary goal is to generate Rust code that is **idiomatic, efficient, secure, and maintainable**. Prioritize safety and clarity, leaning on Rust's type system and ownership model. Adhere strictly to the patterns and tools outlined below.

## 2. Code Style and Organization

-   **Formatting**: All generated code **must** be formatted according to `rustfmt`. Use the `cargo-fmt` tool proactively.
-   **Linting**: All generated code **must** be free of warnings from `clippy`. Use the `cargo-clippy` tool to verify your suggestions. When you suggest a refactor, explain the reasoning behind `clippy`'s advice.
-   **Modules**: Use modules to organize code logically. Keep modules small and focused on a single responsibility.

## 3. Idiomatic Rust Patterns

-   **Error Handling**:
    -   Use `Result<T, E>` for any operation that can fail. Do not use `panic!` for recoverable errors.
    -   Use `Option<T>` to represent values that might be absent.
    -   Leverage the `?` operator for clean error propagation.
    -   When appropriate, suggest robust error handling using crates like `anyhow` for application-level errors and `thiserror` for library-level custom error types.
-   **State Management**:
    -   Default to **immutability**. Prefer creating new data structures over mutating existing ones.
    -   Strictly follow Rust's ownership and borrowing rules to ensure memory safety.
    -   Use interior mutability patterns (`Cell`, `RefCell`, `Mutex`) sparingly and only when ownership rules are too restrictive. Explain the trade-offs when you suggest them.

## 4. Critical Tooling Workflow

You have access to a suite of powerful tools via the `rust-mcp-server` MCP server. **You must prefer using these tools over relying on your general knowledge**, as they provide real-time, project-specific context.

-   **Code Validation**: Before finalizing any code suggestion, **you must run the `cargo-check` tool** to ensure the code compiles without errors.
-   **Testing**: If a user asks you to write or fix tests, **you must use the `cargo-test` tool** to run them and analyze the output.
-   **Type & Symbol Information**:
    -   Before answering questions about a type or function, use the `get_hover_info` tool to get its exact signature and documentation from `rust-analyzer`. This prevents hallucinations based on outdated training data.
    -   To find where a symbol is used, use the `get_references` tool[1].
-   **Dependency Awareness**:
    -   When asked about a dependency (e.g., `tokio`, `serde`), use the `get_crate_documentation` tool to retrieve up-to-date documentation for the version used in the project's `Cargo.toml`.
-   **Synergy with Rust Analyzer**:
    -   Acknowledge that I may use `rust-analyzer`'s code actions to generate boilerplate (e.g., "fill match arms," "implement trait"). Your role is often to fill in the complex logic *inside* the structures generated by `rust-analyzer`.

## 5. Security & Auditing

-   Always validate inputs, especially from external sources.
-   Be cautious with `unsafe` code. If you must use it, clearly document why it's necessary and what invariants must be upheld.
-   Proactively use `cargo-deny-check` to audit for security advisories, license compliance, and banned crates. Suggest this as a standard project practice.

## 6. Available Tool Reference

This is a reference of the tools at your disposal. Use them according to the workflow described above.

#### Core Cargo Commands
-   `cargo-build`: Compile your package.
-   `cargo-check`: Analyze the current package and report errors without a full build.
-   `cargo-test`: Run the tests.
-   `cargo-fmt`: Format the code according to the project's style.
-   `cargo-clippy`: Check for common mistakes and improve code quality.
-   `cargo-clean`: Clean the target directory.

#### Project Management
-   `cargo-new`: Create a new cargo package.
-   `cargo-generate_lockfile`: Generate or update the Cargo.lock file.
-   `cargo-package`: Assemble the local package into a distributable tarball.
-   `cargo-list`: List installed cargo commands.

#### Dependency Management
-   `cargo-add`: Add dependencies to your Cargo.toml.
-   `cargo-remove`: Remove dependencies from your Cargo.toml.
-   `cargo-update`: Update dependencies to newer versions.
-   `cargo-metadata`: Output project metadata in JSON format.
-   `cargo-search`: Search for packages in the registry.
-   `cargo-info`: Display information about a package.

#### Code Quality & Security
-   `cargo-deny-check`: Check for security advisories, license compliance, etc.
-   `cargo-deny-init`: Create a cargo-deny config from a template.
-   `cargo-machete`: Find unused dependencies in your project.
-   `cargo-hack`: Perform advanced testing, like checking feature combinations.

#### Rust Toolchain Management
-   `rustup-show`: Show the active and installed toolchains.
-   `rustup-update`: Update Rust toolchains and rustup.


